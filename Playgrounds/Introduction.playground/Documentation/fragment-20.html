<!DOCTYPE html>
<html lang="en"><head><title>Playground</title><link rel="stylesheet" type="text/css" href="playdown.css"/><meta charset="utf-8"/><meta id="xcode-display" name="xcode-display" content="render"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="viewport" content="width = device-width, maximum-scale=1.0"/></head><body id="conceptual_flow_with_tasks" class="jazz"><div class="content-wrapper"><article class="chapter&gt;"><section class="section"><div><div class="note"><aside class="aside"><p class="para"><span>The <code class="code-voice">ViewModel</code> struct above demonstrates using the <em>Model View ViewModel(MVVM)</em>https://en.wikipedia.org/wiki/Model_View_ViewModel) variant of the traditional <em>Model View Control</em> design pattern for user interfaces. ChannelZ can be used as the data binding layer for implementing MVVM, which has the benefit of being more easily testable and better facilitating the creation of re-usable UI code for cross-platform iOS &amp; Mac apps.</span></p></aside></div><h3 class="section-name">Memory Management</h3><p class="para"><span>Receptors are weakly associated with their target objects, so when the objects are released, their subscriptions are also released. Note that when using closures, the standard practice of declaring <code class="code-voice">[unowned self]</code> is recommended in order to avert retain cycles in your own code.</span></p><h3 class="section-name">Operator Glossary</h3><p class="para">Following is a list of the variants of the ∞ operator that is used throughout the ChannelZ framework:</p><ul class="list-bullet"><li class="item"><p class="para"><span><code class="code-voice">∞(SWTYPE)∞</code>: Wraps the given Swift reference type in a field channel</span></p></li><li class="item"><p class="para"><span><code class="code-voice">ObjC ∞ ObjC.key</code>: Creates a channel to the given Objective-C object's auto-detected KVO-compliant key.</span></p></li><li class="item"><p class="para"><span><code class="code-voice">ObjC ∞ (ObjC.key, "keyPath")</code>: Creates a channel to the given Objective-C's property with a manually specified keypath.</span></p></li><li class="item"><p class="para"><span><code class="code-voice">Fz ∞&gt; { (arg: Type) -&gt; Void }</code>: subscribes a subscription to the given Observable or channel.</span></p></li><li class="item"><p class="para"><span><code class="code-voice">Fz ∞-&gt; { (arg: Type) -&gt; Void }</code>: subscribes a subscription to the given Observable or channel and primes it with the current value.</span></p></li><li class="item"><p class="para"><span><code class="code-voice">Cz1 ∞=&gt; Cz2</code>: Unidirectionally conduits state from channel <code class="code-voice">Cz1</code> to channel <code class="code-voice">Cz2</code>.</span></p></li><li class="item"><p class="para"><span><code class="code-voice">Cz1 ∞=-&gt; Cz2</code>: Unidirectionally conduits state from channel <code class="code-voice">Cz1</code> to channel <code class="code-voice">Cz2</code> and primes the subscription.</span></p></li><li class="item"><p class="para"><span><code class="code-voice">Cz1 &lt;-=∞ Cz2</code>: Unidirectionally conduits state from channel <code class="code-voice">Cz2</code> to channel <code class="code-voice">Cz1</code> and primes the subscription.</span></p></li><li class="item"><p class="para"><span><code class="code-voice">Cz1 &lt;=∞=&gt; Cz2</code>: Bidirectionally conduits state between channels <code class="code-voice">Cz1</code> and <code class="code-voice">Cz2</code>.</span></p></li><li class="item"><p class="para"><span><code class="code-voice">Cz1 &lt;=∞=-&gt; Cz2</code>: Bidirectionally conduits state between channels <code class="code-voice">Cz1</code> and <code class="code-voice">Cz2</code> and primes the right side subscription.</span></p></li><li class="item"><p class="para"><span><code class="code-voice">Cz1 &lt;~∞~&gt; Cz2</code>: Bidirectionally conduits state between channels <code class="code-voice">Cz1</code> and <code class="code-voice">Cz2</code> by coercing numeric types.</span></p></li><li class="item"><p class="para"><span><code class="code-voice">Cz1 &lt;?∞?&gt; Cz2</code>: Bidirectionally conduits state between channels <code class="code-voice">Cz1</code> and <code class="code-voice">Cz2</code> by attempting an optional cast.</span></p></li><li class="item"><p class="para"><span><code class="code-voice">(Cz1 | Cz2) ∞&gt; { (cz1Type?, cz2Type?) -&gt; Void }</code>: subscribe a subscription to the combination of <code class="code-voice">Cz1</code> and <code class="code-voice">Cz2</code> such that when either changes, the subscription will be fired.</span></p></li><li class="item"><p class="para"><span><code class="code-voice">(Cz1 &amp; Cz2) ∞&gt; { (cz1Type, cz2Type) -&gt; Void }</code>: subscribe a subscription to the combination of <code class="code-voice">Cz1</code> and <code class="code-voice">Cz2</code> such that when both change, the subscription will be fired.</span></p></li></ul><h3 class="section-name">Setting up ChannelZ</h3><p class="para"><span><code class="code-voice">ChannelZ</code> is a single cross-platform iOS &amp; Mac Framework. To set it up in your project, simply add it as a github submodule, drag the <code class="code-voice">ChannelZ.xcodeproj</code> into your own project file, add <code class="code-voice">ChannelZ.framework</code> to your target's dependencies, and <code class="code-voice">import ChannelZ</code> from any Swift file that should use it.</span></p><p class="para"><span><strong>Set up Git submodule</strong></span></p><ol class="list-number"><li class="item"><p class="para">Open a Terminal window</p></li><li class="item"><p class="para"><span>Change to your projects directory <code class="code-voice">cd /path/to/MyProject</code></span></p></li><li class="item"><p class="para"><span>If this is a new project, initialize Git: <code class="code-voice">git init</code></span></p></li><li class="item"><p class="para"><span>Add the submodule: <code class="code-voice">git submodule add https://github.com/glimpseio/ChannelZ.git ChannelZ</code>.</span></p></li></ol><p class="para"><span><strong>Set up Xcode</strong></span></p><ol class="list-number"><li class="item"><p class="para"><span>Find the <code class="code-voice">ChannelZ.xcodeproj</code> file inside of the cloned ChannelZ project directory.</span></p></li><li class="item"><p class="para"><span>Drag &amp; Drop it into the <code class="code-voice">Project Navigator</code> (⌘+1).</span></p></li><li class="item"><p class="para"><span>Select your project in the <code class="code-voice">Project Navigator</code> (⌘+1).</span></p></li><li class="item"><p class="para">Select your target.</p></li><li class="item"><p class="para"><span>Select the tab <code class="code-voice">Build Phases</code>.</span></p></li><li class="item"><p class="para"><span>Expand <code class="code-voice">Link Binary With Libraries</code>.</span></p></li><li class="item"><p class="para"><span>Add <code class="code-voice">ChannelZ.framework</code></span></p></li><li class="item"><p class="para"><span>Add <code class="code-voice">import ChannelZ</code> to the top of your Swift source files.</span></p></li></ol><h3 class="section-name">FAQ:</h3><ol class="list-number"><li class="item"><p class="para"><span><strong>Why the Operator ∞?</strong> A common complaint about overloading existing operators (such as +) is that they can defy intuition. ∞ was chosen because it is not used by any other known Swift framework, and so developers are unlikely to have preconceived notions about what it should mean. Also, the infinity symbol is a good metaphor for the infinite nature of modeling state changes over time.</span></p></li><li class="item"><p class="para"><span><strong>Can I use ChannelZ from Objective-C?</strong> No. ChannelZ uses generic, structs, and enums, none of which can be used from Objective-C code. The framework will interact gracefully with any Objective-C code you have, but you cannot access channels from Objective-C, only from Swift.</span></p></li><li class="item"><p class="para"><span><strong>Optionals?</strong></span></p></li><li class="item"><p class="para"><span><strong>NSMutableDictionary keys?</strong></span></p></li><li class="item"><p class="para"><span><strong>System requirements?</strong> ChannelZ requires Xcode 6.1+ with iOS 8.1+ or Mac OS 10.10+.</span></p></li><li class="item"><p class="para"><span><strong>How is automatic keypath identification done?</strong> In order to turn the code <code class="code-voice">ob∞ob.someField</code> into a KVO subscription, we need to figure out that <code class="code-voice">someField</code> is equivalent to the <code class="code-voice">"someField"</code> key path. This is accomplished by temporarily swizzling the class at the time of channel creation in order to instrument the properties and track which property is accessed by the autoclosure, and then immediately swizzling it back to the original class. This is usually transparent, but may fail on classes that dynamically implement their properties, such as Core Data's '<code class="code-voice">NSManagedObject</code>. In those cases, you can always manually specify the key path of a field with the operator variant that takes a tuple with the original value and the name of the property: <code class="code-voice">ob∞(ob.someField, "someField")</code></span></p></li><li class="item"><p class="para"><span><strong>Automatic Keypath Identification Performance?</strong> <code class="code-voice">ob∞ob.someField</code> is about 12x slower than <code class="code-voice">ob∞(ob.someField, "someField")</code></span></p></li><li class="item"><p class="para"><span><strong>Memory management?</strong> All channels are rooted in a reference type: either a reference wrapper around a Swift value, or by the owning class instance itself for KVO. The reference type owns all the subscribed subscriptions, and they are deallocated whenever the reference is released. You shouldn't need to manually track subscriptions and unsubscribe them, although there is nothing preventing you from doing so if you wish.</span></p></li><li class="item"><p class="para"><span><strong>Unstable conduit &amp; reentrancy?</strong> A state channel conduit is considered <em>unstable</em> when it cannot reach equilibrium. For example, <code class="code-voice">ob1∞ob1.intField &lt;=∞=&gt; (ob2∞ob2.intField).map({ $0 + 1 })</code> would mean that setting <code class="code-voice">ob1.intField</code> to 1 would set <code class="code-voice">ob2.intField</code> to 1, and then the map on the channel would cause <code class="code-voice">ob1.intField</code> to be set to 2. This cycle is prevented by limited the levels of re-entrancy that a subscription will allow, and is controlled by the global <code class="code-voice">ChannelZReentrancyLimit</code> field, which default to 1. You can change this value globally if you have channel cycles that may take a few passes to settle into equilibrium.</span></p></li><li class="item"><p class="para"><span><strong>Threading &amp; Queuing?</strong> ChannelZ doesn't touch threads or queues. You can always perform queue jumping yourself in a subscription.</span></p></li><li class="item"><p class="para"><span><strong>UIKit/AppKit and KVO?</strong> <code class="code-voice">UIKit</code>'s <code class="code-voice">UIControl</code> and <code class="code-voice">AppKit</code>'s <code class="code-voice">NSControl</code> are not KVO-compliant for user interaction. For example, the <code class="code-voice">value</code> field of a <code class="code-voice">UISlider</code> does not receive KVO messages when the user drags the slider. We work around this by supplementing channel subscriptions with an additional Observable for the control events. See the <code class="code-voice">KeyValueChannelSupplementing</code> implementation in the <code class="code-voice">UIControl</code> extension for an example of how you can supplement your own control events.</span></p></li><li class="item"><p class="para"><span><strong>Problems?</strong> Please file a Github <em>ChannelZ issue</em>https://github.com/mprudhom/ChannelZ/issues/new).</span></p></li><li class="item"><p class="para"><span><strong>Questions</strong> Please use StackOverflow's <em>#channelz tag</em>http://stackoverflow.com/questions/tagged/channelz).</span></p></li></ol><h2 class="chapter-name">References</h2><ul class="list-bullet"><li class="item"><p class="para"><span><em>Deprecating the Observer Pattern with Scala.React</em>http://infoscience.epfl.ch/record/176887)</span></p></li><li class="item"><p class="para"><span><em>Groovy Parallel Systems</em>http://gpars.codehaus.org/Dataflow)</span></p></li></ul></div></section></article></div></body></html>